<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halfcubes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #fafaf8;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            max-width: 1200px;
            width: 100%;
        }

        canvas {
            border: 1px solid #eee;
            cursor: pointer;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }


        @media (max-width: 600px) {
            canvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas" width="800" height="500"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let progress = 0;
        let targetProgress = 0;

        // Enhanced hand-drawn line with more wobble variation
        function drawWobblyLine(x1, y1, x2, y2, intensity = 1) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);

            const steps = 25;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const x = x1 + (x2 - x1) * t;
                const y = y1 + (y2 - y1) * t;
                const wobble = Math.sin(t * Math.PI * 5) * 0.6 * intensity;
                const microWobble = Math.sin(t * Math.PI * 15) * 0.2 * intensity;
                ctx.lineTo(x + wobble + microWobble, y + wobble + microWobble);
            }

            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }

        // Draw a filled face with subtle shading effect
        function drawFace(points, shade = 0) {
            if (points.length < 3) return;

            // Fill with very subtle shade
            if (shade > 0) {
                ctx.beginPath();
                ctx.moveTo(points[0][0], points[0][1]);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i][0], points[i][1]);
                }
                ctx.closePath();
                const alpha = 0.02 + (shade * 0.03);
                ctx.fillStyle = `rgba(0,0,0,${alpha})`;
                ctx.fill();
            }

            // Draw edges
            for (let i = 0; i < points.length; i++) {
                const next = (i + 1) % points.length;
                drawWobblyLine(points[i][0], points[i][1], points[next][0], points[next][1]);
            }
        }

        function drawCube(offsetX, offsetY, size) {
            // True isometric projection: 30° angle
            // depthX = cos(30°) * size = 0.866 * size
            // depthY = sin(30°) * size = 0.5 * size
            const depthX = size * 0.866;  // horizontal depth (sqrt(3)/2)
            const depthY = size * 0.5;    // vertical depth (1/2)

            // Define all points with proper isometric perspective
            const frontTL = [offsetX, offsetY];
            const frontTR = [offsetX + size, offsetY];
            const frontBR = [offsetX + size, offsetY + size];
            const frontBL = [offsetX, offsetY + size];
            const backTL = [offsetX + depthX, offsetY - depthY];
            const backTR = [offsetX + size + depthX, offsetY - depthY];
            const backBR = [offsetX + size + depthX, offsetY + size - depthY];
            const backBL = [offsetX + depthX, offsetY + size - depthY];

            // Draw faces with subtle shading (back to front)
            drawFace([backTL, backTR, frontTR, frontTL], 1); // Top face
            drawFace([frontTR, backTR, backBR, frontBR], 2); // Right face
            drawFace([frontTL, frontTR, frontBR, frontBL], 0); // Front face
        }

        // Draw half cube with enhanced 3D
        function drawHalfCube(offsetX, offsetY, size, isLeft, rotation = 0) {
            const depthX = size * 0.866;
            const depthY = size * 0.5;
            const halfSize = size / 2;

            if (isLeft) {
                const frontTL = [offsetX, offsetY];
                const frontTR = [offsetX + halfSize, offsetY];
                const frontBR = [offsetX + halfSize, offsetY + size];
                const frontBL = [offsetX, offsetY + size];
                const backTL = [offsetX + depthX, offsetY - depthY];
                const backTR = [offsetX + halfSize + depthX, offsetY - depthY];
                const backBR = [offsetX + halfSize + depthX, offsetY + size - depthY];
                const backBL = [offsetX + depthX, offsetY + size - depthY];

                // Draw the split face (newly exposed interior)
                drawFace([frontTR, backTR, backBR, frontBR], 1);
                // Top face
                drawFace([backTL, backTR, frontTR, frontTL], 1);
                // Front face
                drawFace([frontTL, frontTR, frontBR, frontBL], 0);
            } else {
                const frontTL = [offsetX, offsetY];
                const frontTR = [offsetX + halfSize, offsetY];
                const frontBR = [offsetX + halfSize, offsetY + size];
                const frontBL = [offsetX, offsetY + size];
                const backTL = [offsetX + depthX, offsetY - depthY];
                const backTR = [offsetX + halfSize + depthX, offsetY - depthY];
                const backBR = [offsetX + halfSize + depthX, offsetY + size - depthY];
                const backBL = [offsetX + depthX, offsetY + size - depthY];

                // Draw the split face
                drawFace([frontTL, backTL, backBL, frontBL], 1);
                // Top face
                drawFace([backTL, backTR, frontTR, frontTL], 1);
                // Right face
                drawFace([frontTR, backTR, backBR, frontBR], 2);
                // Front face
                drawFace([frontTL, frontTR, frontBR, frontBL], 0);
            }
        }

        // Diagonal X-cut split
        function drawDiagonalXCut(centerX, centerY, size, splitAmount) {
            const depthX = size * 0.866;
            const depthY = size * 0.5;
            const offset = splitAmount * 0.7;

            // Top-left triangular piece (moves up-left)
            const tl_x = centerX - offset;
            const tl_y = centerY - offset * 0.5;
            const tl1 = [tl_x, tl_y];
            const tl2 = [tl_x + size, tl_y];
            const tl3 = [tl_x + size/2, tl_y + size/2];
            const tl4 = [tl_x + depthX, tl_y - depthY];
            const tl5 = [tl_x + size + depthX, tl_y - depthY];
            const tl6 = [tl_x + size/2 + depthX, tl_y + size/2 - depthY];

            drawFace([tl4, tl5, tl2, tl1], 1);
            drawFace([tl2, tl5, tl6, tl3], 2);
            drawFace([tl1, tl2, tl3], 0);

            // Bottom-right triangular piece (moves down-right)
            const br_x = centerX + offset;
            const br_y = centerY + offset * 0.5;
            const br1 = [br_x + size/2, br_y + size/2];
            const br2 = [br_x + size, br_y + size];
            const br3 = [br_x, br_y + size];
            const br4 = [br_x + size/2 + depthX, br_y + size/2 - depthY];
            const br5 = [br_x + size + depthX, br_y + size - depthY];
            const br6 = [br_x + depthX, br_y + size - depthY];

            drawFace([br4, br5, br2, br1], 2);
            drawFace([br1, br2, br3], 0);
        }

        function animate() {
            progress += (targetProgress - progress) * 0.08;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2 - 70;
            const centerY = canvas.height / 2 - 70;
            const size = 140;

            if (progress < 0.05) {
                drawCube(centerX, centerY, size);
            } else {
                drawDiagonalXCut(centerX, centerY, size, progress * 80);
            }

            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', () => {
            targetProgress = targetProgress === 0 ? 1 : 0;
        });

        animate();
    </script>
</body>
</html>
