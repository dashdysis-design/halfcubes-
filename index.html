<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halfcubes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #fafaf8;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            max-width: 1200px;
            width: 100%;
        }

        canvas {
            border: 1px solid #eee;
            cursor: pointer;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }


        @media (max-width: 600px) {
            canvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas" width="800" height="500"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let progress = 0;
        let targetProgress = 0;

        // Draw a smooth line
        function drawLine(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }

        // Draw a filled face with color and shading
        function drawFace(points, color, drawEdges = true) {
            if (points.length < 3) return;

            // Fill the face
            ctx.beginPath();
            ctx.moveTo(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i][0], points[i][1]);
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();

            // Draw edges
            if (drawEdges) {
                for (let i = 0; i < points.length; i++) {
                    const next = (i + 1) % points.length;
                    drawLine(points[i][0], points[i][1], points[next][0], points[next][1]);
                }
            }
        }

        function drawCube(offsetX, offsetY, size) {
            // True isometric projection for a cube
            // X-axis goes right and down: (0.866, 0.5) * size
            // Y-axis goes left and down: (-0.866, 0.5) * size
            // Z-axis goes straight up: (0, -1) * size

            const s = size;

            // Bottom face vertices
            const v0 = [offsetX, offsetY + s]; // origin
            const v1 = [offsetX + s * 0.866, offsetY + s + s * 0.5]; // +X
            const v2 = [offsetX, offsetY + s + s]; // +Y
            const v3 = [offsetX - s * 0.866, offsetY + s + s * 0.5]; // +X+Y

            // Top face vertices (same but shifted up by size)
            const v4 = [offsetX, offsetY]; // origin + Z
            const v5 = [offsetX + s * 0.866, offsetY + s * 0.5]; // +X + Z
            const v6 = [offsetX, offsetY + s]; // +Y + Z
            const v7 = [offsetX - s * 0.866, offsetY + s * 0.5]; // +X+Y + Z

            // Draw faces (back to front for proper occlusion)
            drawFace([v3, v7, v6, v2], '#B22222'); // Back face
            drawFace([v2, v6, v4, v0], '#CD5C5C'); // Left face
            drawFace([v0, v4, v5, v1], '#DC143C'); // Right face
            drawFace([v1, v5, v7, v3], '#FF6347'); // Front face
            drawFace([v4, v5, v7, v6], '#FF7F50'); // Top face
        }

        // Draw half cube with enhanced 3D
        function drawHalfCube(offsetX, offsetY, size, isLeft, rotation = 0) {
            const depthX = size * 0.866;
            const depthY = size * 0.5;
            const halfSize = size / 2;

            if (isLeft) {
                const frontTL = [offsetX, offsetY];
                const frontTR = [offsetX + halfSize, offsetY];
                const frontBR = [offsetX + halfSize, offsetY + size];
                const frontBL = [offsetX, offsetY + size];
                const backTL = [offsetX + depthX, offsetY - depthY];
                const backTR = [offsetX + halfSize + depthX, offsetY - depthY];
                const backBR = [offsetX + halfSize + depthX, offsetY + size - depthY];
                const backBL = [offsetX + depthX, offsetY + size - depthY];

                // Draw the split face (newly exposed interior)
                drawFace([frontTR, backTR, backBR, frontBR], 1);
                // Top face
                drawFace([backTL, backTR, frontTR, frontTL], 1);
                // Front face
                drawFace([frontTL, frontTR, frontBR, frontBL], 0);
            } else {
                const frontTL = [offsetX, offsetY];
                const frontTR = [offsetX + halfSize, offsetY];
                const frontBR = [offsetX + halfSize, offsetY + size];
                const frontBL = [offsetX, offsetY + size];
                const backTL = [offsetX + depthX, offsetY - depthY];
                const backTR = [offsetX + halfSize + depthX, offsetY - depthY];
                const backBR = [offsetX + halfSize + depthX, offsetY + size - depthY];
                const backBL = [offsetX + depthX, offsetY + size - depthY];

                // Draw the split face
                drawFace([frontTL, backTL, backBL, frontBL], 1);
                // Top face
                drawFace([backTL, backTR, frontTR, frontTL], 1);
                // Right face
                drawFace([frontTR, backTR, backBR, frontBR], 2);
                // Front face
                drawFace([frontTL, frontTR, frontBR, frontBL], 0);
            }
        }

        // Depth split (front and back halves) - isometric
        function drawDepthSplit(centerX, centerY, size, splitAmount) {
            const s = size;
            const offset = splitAmount * 0.433; // Split offset

            // FRONT HALF - moves left
            const fx = centerX - offset;
            const fy = centerY + s;

            // Front half bottom vertices (half depth in Y direction)
            const f0 = [fx, fy];
            const f1 = [fx + s * 0.866, fy + s * 0.5];
            const f2 = [fx, fy + s * 0.5]; // Half depth
            const f3 = [fx - s * 0.866, fy]; // Closing the trapezoid

            // Front half top vertices
            const f4 = [fx, fy - s];
            const f5 = [fx + s * 0.866, fy - s * 0.5];
            const f6 = [fx, fy - s * 0.5]; // Half depth
            const f7 = [fx - s * 0.866, fy - s]; // Closing the trapezoid

            // BACK HALF - moves right
            const bx = centerX + offset;
            const by = centerY + s + s * 0.5;

            // Back half bottom vertices (starts at middle depth)
            const b0 = [bx, by];
            const b1 = [bx + s * 0.866, by + s * 0.5];
            const b2 = [bx, by + s * 0.5];
            const b3 = [bx - s * 0.866, by];

            // Back half top vertices
            const b4 = [bx, by - s];
            const b5 = [bx + s * 0.866, by - s * 0.5];
            const b6 = [bx, by - s * 0.5];
            const b7 = [bx - s * 0.866, by - s];

            // Draw front half
            drawFace([f0, f4, f5, f1], '#DC143C'); // Right face
            drawFace([f1, f5, f7, f3], '#FF6347'); // Front face
            drawFace([f4, f5, f7, f6], '#FF7F50'); // Top face
            drawFace([f2, f6, f5, f1], '#8B0000'); // Cut surface (dark)
            drawFace([f3, f7, f6, f2], '#CD5C5C'); // Left face

            // Draw back half
            drawFace([b2, b6, b4, b0], '#CD5C5C'); // Left face
            drawFace([b0, b4, b5, b1], '#DC143C'); // Right face
            drawFace([b3, b7, b6, b2], '#B22222'); // Back face
            drawFace([b4, b5, b7, b6], '#FF7F50'); // Top face
            drawFace([b0, b4, b7, b3], '#8B0000'); // Cut surface (dark)
        }

        function animate() {
            progress += (targetProgress - progress) * 0.08;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2 - 70;
            const centerY = canvas.height / 2 - 70;
            const size = 140;

            if (progress < 0.05) {
                drawCube(centerX, centerY, size);
            } else {
                drawDepthSplit(centerX, centerY, size, progress * 80);
            }

            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', () => {
            targetProgress = targetProgress === 0 ? 1 : 0;
        });

        animate();
    </script>
</body>
</html>
