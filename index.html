<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halfcubes</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #fafaf8;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            max-width: 1200px;
            width: 100%;
        }

        canvas {
            cursor: pointer;
            display: block;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 600px;
        }

        button {
            padding: 12px 20px;
            background: white;
            border: 2px solid #2a2a2a;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        button:hover {
            background: #f0f0f0;
            transform: translateY(-2px);
        }

        button.active {
            background: #2a2a2a;
            color: white;
        }

        @media (max-width: 600px) {
            canvas {
                width: 100%;
                height: auto;
            }

            .buttons {
                gap: 8px;
            }

            button {
                padding: 10px 16px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas" width="800" height="500"></canvas>
        <div class="buttons">
            <button onclick="setAnimation('split')" class="active">1. Split</button>
            <button onclick="setAnimation('slice')">2. Slice</button>
            <button onclick="setAnimation('collapse')">3. Collapse</button>
            <button onclick="setAnimation('fold')">4. Fold</button>
            <button onclick="setAnimation('curve')">5. Curve</button>
            <button onclick="setAnimation('diagonal')">6. Diagonal</button>
            <button onclick="setAnimation('peel')">7. Peel</button>
        </div>
    </div>

    <script>
        // Three.js setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-3, 3, 2, -2, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(800, 500);
        renderer.setClearColor(0xfafaf8, 1);

        // Camera position for isometric view
        camera.position.set(5, 3, 5);
        camera.lookAt(0, 0, 0);

        let progress = 0;
        let targetProgress = 0;
        let currentAnimation = 'split';
        let cube1, cube2;

        // Colors
        const materials = [
            new THREE.MeshBasicMaterial({ color: 0x960300 }), // right - darkest
            new THREE.MeshBasicMaterial({ color: 0x560000 }), // left - dark
            new THREE.MeshBasicMaterial({ color: 0xaf0400 }), // top - bright
            new THREE.MeshBasicMaterial({ color: 0x960300 }), // bottom
            new THREE.MeshBasicMaterial({ color: 0xaf0400 }), // front
            new THREE.MeshBasicMaterial({ color: 0x560000 })  // back
        ];

        // Load sound effects
        const splitSound = new Audio('moan%231.mp3');
        const mergeSound = new Audio('moan%232.mp3');
        splitSound.volume = 0.5;
        mergeSound.volume = 0.5;

        function createCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            return new THREE.Mesh(geometry, materials);
        }

        // Create custom wedge geometry for diagonal cut
        function createWedge(isLeft) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(isLeft ? [
                // Left wedge - triangular prism
                -0.5, -0.5, -0.5,  // 0: bottom left back
                 0.5, -0.5, -0.5,  // 1: bottom right back
                -0.5,  0.5, -0.5,  // 2: top left back
                -0.5, -0.5,  0.5,  // 3: bottom left front
                 0.5, -0.5,  0.5,  // 4: bottom right front
                -0.5,  0.5,  0.5,  // 5: top left front
            ] : [
                // Right wedge - triangular prism
                -0.5, -0.5, -0.5,  // 0: bottom left back
                 0.5, -0.5, -0.5,  // 1: bottom right back
                 0.5,  0.5, -0.5,  // 2: top right back
                -0.5, -0.5,  0.5,  // 3: bottom left front
                 0.5, -0.5,  0.5,  // 4: bottom right front
                 0.5,  0.5,  0.5,  // 5: top right front
            ]);

            const indices = isLeft ? [
                0,1,2, 1,4,2, 2,4,5, 0,2,5, 0,5,3, 0,3,1, 1,3,4, 3,5,4
            ] : [
                0,1,2, 0,4,1, 2,4,5, 0,2,5, 0,5,3, 0,3,1, 1,4,2, 3,5,4
            ];

            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            return new THREE.Mesh(geometry, materials);
        }

        // Create curved piece geometry
        function createCurvedPiece(isLeft, curvature = 0) {
            const geometry = new THREE.BoxGeometry(0.5, 1, 1, 4, 1, 1);
            const positions = geometry.attributes.position;

            // Apply curve deformation
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i);
                const offset = Math.sin(y * Math.PI) * curvature;
                positions.setX(i, positions.getX(i) + offset * (isLeft ? -1 : 1));
            }

            geometry.computeVertexNormals();
            return new THREE.Mesh(geometry, materials);
        }

        function setAnimation(animType) {
            currentAnimation = animType;
            targetProgress = 0;
            progress = 0;

            // Update button states
            document.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function animate() {
            progress += (targetProgress - progress) * 0.12;

            // Clear scene
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            const p = progress;
            const dist = p * 1.5;

            if (p < 0.05) {
                // Draw whole cube
                const cube = createCube();
                scene.add(cube);
            } else {
                // Draw animation based on current type
                switch(currentAnimation) {
                    case 'split':
                        // Animation 1: Vertical split
                        cube1 = createCube();
                        cube2 = createCube();
                        cube1.scale.x = 0.5;
                        cube2.scale.x = 0.5;
                        cube1.position.x = -0.25 - dist * 0.5;
                        cube2.position.x = 0.25 + dist * 0.5;
                        scene.add(cube1, cube2);
                        break;

                    case 'slice':
                        // Animation 2: Horizontal slice (Y-axis)
                        cube1 = createCube();
                        cube2 = createCube();
                        cube1.scale.y = 0.5;
                        cube2.scale.y = 0.5;
                        cube1.position.y = -0.25 - dist * 0.5;
                        cube2.position.y = 0.25 + dist * 0.5;
                        scene.add(cube1, cube2);
                        break;

                    case 'collapse':
                        // Animation 3: Collapse inward
                        cube1 = createCube();
                        const scale = 1 - p * 0.4;
                        cube1.scale.set(scale, scale, scale);
                        scene.add(cube1);
                        break;

                    case 'fold':
                        // Animation 4: Top folds down
                        cube1 = createCube();
                        cube2 = createCube();
                        cube1.scale.z = 0.5;
                        cube2.scale.z = 0.5;
                        cube1.position.z = -0.25;
                        cube2.position.z = 0.25;
                        cube2.rotation.x = p * Math.PI / 2;
                        cube2.position.y = -p * 0.5;
                        scene.add(cube1, cube2);
                        break;

                    case 'curve':
                        // Animation 5: Curved cut with actual curved geometry
                        cube1 = createCurvedPiece(true, p * 0.3);
                        cube2 = createCurvedPiece(false, p * 0.3);
                        cube1.position.set(-0.25 - dist * 0.4, 0, 0);
                        cube2.position.set(0.25 + dist * 0.4, 0, 0);
                        scene.add(cube1, cube2);
                        break;

                    case 'diagonal':
                        // Animation 6: Diagonal slice with wedge geometry
                        cube1 = createWedge(true);
                        cube2 = createWedge(false);
                        cube1.position.set(-dist * 0.5, 0, 0);
                        cube2.position.set(dist * 0.5, 0, 0);
                        scene.add(cube1, cube2);
                        break;

                    case 'peel':
                        // Animation 7: Corner peel
                        cube1 = createCube();
                        cube2 = createCube();
                        cube1.scale.x = 0.75;
                        cube2.scale.x = 0.25;
                        cube1.position.x = -0.125;
                        cube2.position.set(0.375 + dist * 0.5, p * 0.5, p * 0.5);
                        cube2.rotation.y = p * Math.PI / 3;
                        cube2.rotation.z = -p * Math.PI / 6;
                        scene.add(cube1, cube2);
                        break;
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', () => {
            const newTarget = targetProgress === 0 ? 1 : 0;

            // Play appropriate sound
            if (newTarget === 1) {
                splitSound.currentTime = 0;
                splitSound.play().catch(e => console.log('Audio play failed:', e));
            } else {
                mergeSound.currentTime = 0;
                mergeSound.play().catch(e => console.log('Audio play failed:', e));
            }

            targetProgress = newTarget;
        });

        animate();
    </script>
</body>
</html>
